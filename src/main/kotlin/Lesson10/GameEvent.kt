package Lesson10

// У нас на данном этапе есть корутины, время, бой, эффекты и баффы
// Но само по себе это просто набор компонентов. Для них нужен связывающий слой
// Его называют по разному Event System / Event Bus / Система событий (тригеров)

//////////////////////////// === ЗАЧЕМ НУЖНЫ СОБЫТИЯ === /////////////////////////////////////
// Без системы событий:
// Квесты не знают, что кто-то умер, или завершил, или вышел из игры
// NPC не знают, что кто-то умер
// UI (User Interface) не знает, что какое-то игровое состояние было изменено
// Сервер и клиент не знают, что произошло в мире, что с этим делать и как это синхронизировать

// Система событий - это реакция мира на действие игрока(ов)
// Событие само по себе ничего не делает, это просто сообщение о том, что что-то произошло, и дает команду, что-то сделать
    // Примеры событий:
    // Персонаж умер / Квест выполнен / Игрок попал в зону(локацию) / Игрок ударил по другому игроку / Выход из игры / NPC изменил состояние (торгует/спит)
// ВАЖНО!!!!!! событие: не
// 1. не выполняет какую либо логику
// 2. не знает и не возвращает информацию о том кто на это событие отреагировал или получил
// Грубо говоря: "Эй сервер/клиент только что игрок пнул npc name"

////////////////// АНАЛОГИЯ ///////////////////////////
// Игрок убивает моба
// СТАНДАРТНАЯ ИГРОВАЯ ЦЕПОЧКА (НЕ ПРАВИЛЬНЫХ)!!!!!!!
// <Если убили моба> -> Проверить квест -> обновить UI -> дать опыт -> обновить состояние npc -> сохранить прогресс
// Это жесткая цепочка которая может прерваться или сломаться если что-то пошло не так или что-то сделано одновременно
/////// Правильная система:
// <Моб умирает> -> Событие Уведомляет
// Потом когда событие случилось
// 1. Квест "слушает" событие е если оно соответствует требованиям квеста -> обновить квест
// 2. UI слушает событие -> обновляет информацию информацию о статусе квеста
// 3. Система инвентаря слушает -> дропает из моба заготовленный предмет с шансом
// 4. Лог сервера слушает событие -> пишет информацию в консоль

// Есть событие и есть их подписчики
// Событие CharacterDied - его подписчик это NPC и Quest
// Подписчиками - мы называем тех кто слушает данное событие.

// sealed class это класс с закрытой иерархией классов
// 1. Все возможные типы событий будут перечисленны только здесь
// 2. Компилятор Kotlin будет сразу знать все варианты событий из данного класса
sealed class GameEvent{
    // sealed - базовый тип любого игрового класса

    // Событие смерти персонажа
    data class CharacterDied(
        val characterName: String
    ) :GameEvent()
    // :GameEvent() - наследование обязательно, для причисления к данной иерархии

    data class EffectApplied(
        val characterName: String,
        val effectName: String
    ) : GameEvent()

    data class QuestCompleted(
        val questId: String
    ) : GameEvent()

    data class DialogStarted(
        val DialogChoiceSelected: String
    ): GameEvent()

}
// sealed - обязателен для графов состояний событий и тд.
// Благодаря ему - мы заранее знаем ВСЕ ДО ЕДИНОГО типа событий (и так же знаем что дополняется они в одном месте)
// Мы НЕ может создать новый тип события из-ниоткуда кроме как в данном sealed
// Защита от ошибок и конфликтов событий легко дополняется в одном месте и не нарушает логики (безопасность логических операций)


















